"use client";

import Link from "next/link";
import { useParams } from "next/navigation";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { addDoc, onSnapshot, query, where } from "firebase/firestore";
import {
  ROOM_HEARTBEAT_MS,
  MAX_PARTICIPANTS,
  candidatesCollectionRef,
  joinRoom,
  heartbeatParticipant,
  leaveRoom,
  signalsCollectionRef,
  subscribeParticipants
} from "@/lib/room";
import { createAudioPeerConnection, requestMicrophoneStream } from "@/lib/webrtc";
import type { IceCandidateDoc, ParticipantDoc, SignalDoc } from "@/types/rtc";

type JoinState = "joining" | "ready" | "full" | "error";

const PIN_REGEX = /^\d{4}$/;
const REMOTE_SPEAKING_THRESHOLD = 0.03;
const REMOTE_SIGNAL_POLL_MS = 140;
const REMOTE_LEVEL_SMOOTHING = 0.35;

export default function RoomPage() {
  const params = useParams<{ roomId: string }>();
  const roomId = useMemo(() => {
    const rawValue = params?.roomId;
    const raw = Array.isArray(rawValue) ? rawValue[0] ?? "" : rawValue ?? "";
    return decodeURIComponent(raw).trim();
  }, [params?.roomId]);
  const isValidPin = useMemo(() => PIN_REGEX.test(roomId), [roomId]);

  const [clientId, setClientId] = useState<string | null>(null);
  const [joinState, setJoinState] = useState<JoinState>("joining");
  const [participants, setParticipants] = useState<ParticipantDoc[]>([]);
  const [connectionState, setConnectionState] = useState<RTCPeerConnectionState>("new");
  const [isTransmitting, setIsTransmitting] = useState(false);
  const [isHolding, setIsHolding] = useState(false);
  const [micReady, setMicReady] = useState(false);
  const [level, setLevel] = useState(0);
  const [remoteLevel, setRemoteLevel] = useState(0);
  const [audioUnlockNeeded, setAudioUnlockNeeded] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [busyMessage, setBusyMessage] = useState<string | null>(null);
  const [copied, setCopied] = useState(false);

  const clientIdRef = useRef<string | null>(null);
  const startedRef = useRef(false);
  const pressingRef = useRef(false);
  const localStreamRef = useRef<MediaStream | null>(null);
  const localTrackRef = useRef<MediaStreamTrack | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const meterRafRef = useRef<number | null>(null);
  const remoteSignalIntervalRef = useRef<number | null>(null);
  const remotePollInFlightRef = useRef(false);
  const pttDownAudioRef = useRef<HTMLAudioElement | null>(null);
  const pttUpAudioRef = useRef<HTMLAudioElement | null>(null);
  const backgroundLoopRef = useRef<HTMLAudioElement | null>(null);
  const heartbeatIntervalRef = useRef<number | null>(null);
  const busyTimeoutRef = useRef<number | null>(null);
  const roomUnsubRef = useRef<(() => void) | null>(null);

  const peerConnectionsRef = useRef<Map<string, RTCPeerConnection>>(new Map());
  const peerUnsubsRef = useRef<Map<string, () => void>>(new Map());
  const peerCandidatesRef = useRef<Map<string, Set<string>>>(new Map());
  const peerSignalsRef = useRef<Map<string, Set<string>>>(new Map());
  const peerAudioRef = useRef<Map<string, HTMLAudioElement>>(new Map());
  const offeredPeersRef = useRef<Set<string>>(new Set());

  const setTransientBusyMessage = useCallback((message: string) => {
    setBusyMessage(message);

    if (busyTimeoutRef.current !== null) {
      window.clearTimeout(busyTimeoutRef.current);
    }

    busyTimeoutRef.current = window.setTimeout(() => {
      setBusyMessage(null);
      busyTimeoutRef.current = null;
    }, 1_500);
  }, []);

  const clearTransmissionState = useCallback(() => {
    pressingRef.current = false;
    setIsHolding(false);
    setIsTransmitting(false);
    setLevel(0);

    if (localTrackRef.current) {
      localTrackRef.current.enabled = false;
    }
  }, []);

  const ensureSfx = useCallback(() => {
    if (!pttDownAudioRef.current) {
      pttDownAudioRef.current = new Audio("/sfx/start.m4a");
      pttDownAudioRef.current.volume = 0.65;
    }
    if (!pttUpAudioRef.current) {
      pttUpAudioRef.current = new Audio("/sfx/end.flac");
      pttUpAudioRef.current.volume = 0.65;
    }
    if (!backgroundLoopRef.current) {
      const loop = new Audio("/sfx/crispsound.wav");
      loop.loop = true;
      loop.volume = 0.2;
      backgroundLoopRef.current = loop;
    }
  }, []);

  const playSfx = useCallback((audioRef: React.MutableRefObject<HTMLAudioElement | null>) => {
    if (!audioRef.current) {
      return;
    }
    audioRef.current.currentTime = 0;
    void audioRef.current.play().catch(() => {
      // Autoplay can be blocked; ignore.
    });
  }, []);

  const startBackgroundLoop = useCallback(() => {
    ensureSfx();
    if (!backgroundLoopRef.current) {
      return;
    }
    void backgroundLoopRef.current.play().catch(() => {
      // Autoplay can be blocked.
    });
  }, [ensureSfx]);

  const stopBackgroundLoop = useCallback(() => {
    if (backgroundLoopRef.current) {
      backgroundLoopRef.current.pause();
      backgroundLoopRef.current.currentTime = 0;
    }
  }, []);

  const stopTalking = useCallback(async () => {
    clearTransmissionState();
  }, [clearTransmissionState]);

  const ensurePeerAudioElement = useCallback((peerId: string): HTMLAudioElement => {
    let audio = peerAudioRef.current.get(peerId);
    if (audio) {
      return audio;
    }

    audio = new Audio();
    audio.autoplay = true;
    audio.preload = "auto";
    audio.muted = false;
    audio.volume = 1;
    (audio as HTMLAudioElement & { playsInline?: boolean }).playsInline = true;
    peerAudioRef.current.set(peerId, audio);
    return audio;
  }, []);

  const resumeRemoteAudioPlayback = useCallback(async () => {
    if (audioContextRef.current?.state === "suspended") {
      try {
        await audioContextRef.current.resume();
      } catch {
        // Ignore blocked resume.
      }
    }

    let blocked = false;
    for (const audio of peerAudioRef.current.values()) {
      try {
        await audio.play();
      } catch {
        blocked = true;
      }
    }

    setAudioUnlockNeeded(blocked);
  }, []);

  const attachRemoteStream = useCallback(
    (peerId: string, stream: MediaStream) => {
      const audio = ensurePeerAudioElement(peerId);
      if (audio.srcObject !== stream) {
        audio.srcObject = stream;
      }

      void audio.play().catch(() => {
        setAudioUnlockNeeded(true);
      });
    },
    [ensurePeerAudioElement]
  );

  const closePeerConnections = useCallback(() => {
    for (const [, pc] of peerConnectionsRef.current.entries()) {
      pc.onicecandidate = null;
      pc.ontrack = null;
      pc.onconnectionstatechange = null;
      pc.close();
    }
    peerConnectionsRef.current.clear();

    for (const [, unsub] of peerUnsubsRef.current.entries()) {
      unsub();
    }
    peerUnsubsRef.current.clear();

    for (const [, audio] of peerAudioRef.current.entries()) {
      audio.pause();
      audio.srcObject = null;
    }
    peerAudioRef.current.clear();

    peerCandidatesRef.current.clear();
    peerSignalsRef.current.clear();
    offeredPeersRef.current.clear();
    setAudioUnlockNeeded(false);
    setRemoteLevel(0);
    setConnectionState("new");
  }, []);

  const attachPeerListeners = useCallback(
    (peerId: string, pc: RTCPeerConnection) => {
      const clientIdNow = clientIdRef.current;
      if (!clientIdNow) {
        return;
      }

      const candidatesSet = new Set<string>();
      peerCandidatesRef.current.set(peerId, candidatesSet);
      const signalsSet = new Set<string>();
      peerSignalsRef.current.set(peerId, signalsSet);

      pc.onicecandidate = (event) => {
        if (!event.candidate) {
          return;
        }

        const payload: IceCandidateDoc = {
          from: clientIdNow,
          to: peerId,
          candidate: event.candidate.toJSON(),
          createdAt: Date.now()
        };

        void addDoc(candidatesCollectionRef(roomId), payload).catch(() => {
          // Ignore transient write failures.
        });
      };

      pc.ontrack = (event) => {
        const [stream] = event.streams;
        if (!stream) {
          return;
        }
        attachRemoteStream(peerId, stream);
      };

      pc.onconnectionstatechange = () => {
        setConnectionState(pc.connectionState);
      };

      // Use only a single where() to avoid composite index requirements.
      const signalsQuery = query(signalsCollectionRef(roomId), where("to", "==", clientIdNow));
      const candidatesQuery = query(candidatesCollectionRef(roomId), where("to", "==", clientIdNow));

      const unsubs: Array<() => void> = [];

      unsubs.push(
        onSnapshot(signalsQuery, async (snapshot) => {
          for (const change of snapshot.docChanges()) {
            if (change.type !== "added") {
              continue;
            }

            if (signalsSet.has(change.doc.id)) {
              continue;
            }

            const data = change.doc.data() as SignalDoc & { type: "offer" | "answer" };
            if (data.from !== peerId) {
              continue;
            }

            signalsSet.add(change.doc.id);

            if (data.type === "offer") {
              try {
                await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                await addDoc(signalsCollectionRef(roomId), {
                  from: clientIdNow,
                  to: peerId,
                  type: "answer",
                  sdp: answer,
                  createdAt: Date.now()
                });
              } catch {
                // Ignore stale offers.
              }
            } else if (data.type === "answer") {
              try {
                if (pc.signalingState === "have-local-offer") {
                  await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                }
              } catch {
                // Ignore stale answers.
              }
            }
          }
        })
      );

      unsubs.push(
        onSnapshot(candidatesQuery, (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            if (change.type !== "added") {
              return;
            }

            if (candidatesSet.has(change.doc.id)) {
              return;
            }
            candidatesSet.add(change.doc.id);

            const data = change.doc.data() as IceCandidateDoc;
            if (data.from !== peerId) {
              return;
            }
            void pc.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(() => {
              // Ignore stale candidates.
            });
          });
        })
      );

      peerUnsubsRef.current.set(peerId, () => {
        unsubs.forEach((unsub) => unsub());
      });
    },
    [attachRemoteStream, roomId]
  );

  const createPeerConnection = useCallback(
    (peerId: string): RTCPeerConnection => {
      const localStream = localStreamRef.current;
      if (!localStream) {
        throw new Error("Flux micro indisponible.");
      }

      const pc = createAudioPeerConnection({
        localStream,
        onRemoteStream: (stream) => {
          attachRemoteStream(peerId, stream);
        },
        onConnectionStateChange: (state) => {
          setConnectionState(state);
        }
      });

      attachPeerListeners(peerId, pc);
      peerConnectionsRef.current.set(peerId, pc);
      return pc;
    },
    [attachPeerListeners, attachRemoteStream]
  );

  const canTransmit = useMemo(
    () => joinState === "ready" && clientId !== null && micReady,
    [clientId, joinState, micReady]
  );
  const remoteSpeaking = remoteLevel > REMOTE_SPEAKING_THRESHOLD;

  const startTalking = useCallback(async () => {
    if (!canTransmit || isTransmitting) {
      return;
    }

    if (!localTrackRef.current) {
      return;
    }

    localTrackRef.current.enabled = true;
    setIsTransmitting(true);
    setBusyMessage(null);
  }, [canTransmit, isTransmitting]);

  const handlePressStart = useCallback(() => {
    if (joinState !== "ready") {
      return;
    }

    if (pressingRef.current) {
      return;
    }

    pressingRef.current = true;
    void resumeRemoteAudioPlayback();
    setIsHolding(true);
    ensureSfx();
    playSfx(pttDownAudioRef);
    void startTalking();
  }, [ensureSfx, joinState, playSfx, resumeRemoteAudioPlayback, startTalking]);

  const handlePressEnd = useCallback(() => {
    setIsHolding(false);
    ensureSfx();
    playSfx(pttUpAudioRef);
    void stopTalking();
  }, [ensureSfx, playSfx, stopTalking]);

  const copyLink = useCallback(async () => {
    try {
      await navigator.clipboard.writeText(window.location.href);
      setCopied(true);
      window.setTimeout(() => setCopied(false), 1_500);
    } catch {
      setError("Impossible de copier le lien.");
    }
  }, []);

  useEffect(() => {
    clientIdRef.current = clientId;
  }, [clientId]);

  useEffect(() => {
    if (isTransmitting && !micReady) {
      void stopTalking();
    }
  }, [isTransmitting, micReady, stopTalking]);

  useEffect(() => {
    const speaking = isTransmitting || remoteSpeaking;
    if (speaking) {
      startBackgroundLoop();
    } else {
      stopBackgroundLoop();
    }
  }, [isTransmitting, remoteSpeaking, startBackgroundLoop, stopBackgroundLoop]);

  useEffect(() => {
    const keydown = (event: KeyboardEvent) => {
      if (event.code !== "Space" || event.repeat) {
        return;
      }

      event.preventDefault();
      handlePressStart();
    };

    const keyup = (event: KeyboardEvent) => {
      if (event.code !== "Space") {
        return;
      }

      event.preventDefault();
      handlePressEnd();
    };

    window.addEventListener("keydown", keydown);
    window.addEventListener("keyup", keyup);

    return () => {
      window.removeEventListener("keydown", keydown);
      window.removeEventListener("keyup", keyup);
    };
  }, [handlePressEnd, handlePressStart]);

  useEffect(() => {
    if (!audioUnlockNeeded) {
      return;
    }

    const unlock = () => {
      void resumeRemoteAudioPlayback();
    };

    window.addEventListener("pointerdown", unlock);
    window.addEventListener("keydown", unlock);

    return () => {
      window.removeEventListener("pointerdown", unlock);
      window.removeEventListener("keydown", unlock);
    };
  }, [audioUnlockNeeded, resumeRemoteAudioPlayback]);

  useEffect(() => {
    if (!micReady || !localStreamRef.current) {
      return;
    }

    if (!audioContextRef.current) {
      audioContextRef.current = new AudioContext();
    }

    const context = audioContextRef.current;
    const analyser = context.createAnalyser();
    analyser.fftSize = 512;
    analyser.smoothingTimeConstant = 0.8;
    analyserRef.current = analyser;

    const source = context.createMediaStreamSource(localStreamRef.current);
    source.connect(analyser);

    const data = new Uint8Array(analyser.frequencyBinCount);

    const tick = () => {
      analyser.getByteTimeDomainData(data);
      let sum = 0;
      for (let i = 0; i < data.length; i += 1) {
        const v = (data[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / data.length);
      const next = Math.min(1, Math.max(0, rms * 2.2));
      setLevel(next);
      meterRafRef.current = window.requestAnimationFrame(tick);
    };

    meterRafRef.current = window.requestAnimationFrame(tick);

    return () => {
      source.disconnect();
      analyser.disconnect();
      if (meterRafRef.current !== null) {
        window.cancelAnimationFrame(meterRafRef.current);
        meterRafRef.current = null;
      }
    };
  }, [micReady]);

  useEffect(() => {
    let cancelled = false;

    const pollRemoteLevel = async () => {
      if (remotePollInFlightRef.current) {
        return;
      }
      remotePollInFlightRef.current = true;

      try {
        let peakLevel = 0;

        for (const pc of peerConnectionsRef.current.values()) {
          for (const receiver of pc.getReceivers()) {
            if (receiver.track?.kind !== "audio") {
              continue;
            }

            if (typeof receiver.getSynchronizationSources === "function") {
              const sources = receiver.getSynchronizationSources();
              for (const source of sources) {
                if (typeof source.audioLevel === "number") {
                  peakLevel = Math.max(peakLevel, source.audioLevel);
                }
              }
            }

            try {
              const stats = await receiver.getStats();
              stats.forEach((report) => {
                if (report.type !== "inbound-rtp") {
                  return;
                }

                const statsReport = report as RTCInboundRtpStreamStats & {
                  audioLevel?: number;
                  kind?: string;
                  mediaType?: string;
                };
                const isAudio = statsReport.kind === "audio" || statsReport.mediaType === "audio";
                if (!isAudio || typeof statsReport.audioLevel !== "number") {
                  return;
                }

                peakLevel = Math.max(peakLevel, statsReport.audioLevel);
              });
            } catch {
              // Stats can fail on closed receivers; ignore.
            }
          }
        }

        if (cancelled) {
          return;
        }

        setRemoteLevel((prev) => {
          const eased = prev + (peakLevel - prev) * REMOTE_LEVEL_SMOOTHING;
          return eased < 0.004 ? 0 : eased;
        });
      } finally {
        remotePollInFlightRef.current = false;
      }
    };

    void pollRemoteLevel();
    remoteSignalIntervalRef.current = window.setInterval(() => {
      void pollRemoteLevel();
    }, REMOTE_SIGNAL_POLL_MS);

    return () => {
      cancelled = true;
      remotePollInFlightRef.current = false;
      if (remoteSignalIntervalRef.current !== null) {
        window.clearInterval(remoteSignalIntervalRef.current);
        remoteSignalIntervalRef.current = null;
      }
    };
  }, []);

  useEffect(() => {
    if (!clientId) {
      return;
    }

    const activePeers = participants.filter((participant) => participant.id !== clientId).map((p) => p.id);

    for (const peerId of activePeers) {
      if (peerConnectionsRef.current.has(peerId)) {
        continue;
      }

      const pc = createPeerConnection(peerId);
      if (clientId < peerId && !offeredPeersRef.current.has(peerId)) {
        offeredPeersRef.current.add(peerId);
        void (async () => {
          try {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            await addDoc(signalsCollectionRef(roomId), {
              from: clientId,
              to: peerId,
              type: "offer",
              sdp: offer,
              createdAt: Date.now()
            });
          } catch {
            setTransientBusyMessage("Connexion audio impossible.");
          }
        })();
      }
    }

    for (const peerId of peerConnectionsRef.current.keys()) {
      if (!activePeers.includes(peerId)) {
        const pc = peerConnectionsRef.current.get(peerId);
        if (pc) {
          pc.onicecandidate = null;
          pc.ontrack = null;
          pc.onconnectionstatechange = null;
          pc.close();
        }
        peerConnectionsRef.current.delete(peerId);

        const unsub = peerUnsubsRef.current.get(peerId);
        if (unsub) {
          unsub();
        }
        peerUnsubsRef.current.delete(peerId);

        peerCandidatesRef.current.delete(peerId);
        peerSignalsRef.current.delete(peerId);
        offeredPeersRef.current.delete(peerId);

        const audio = peerAudioRef.current.get(peerId);
        if (audio) {
          audio.pause();
          audio.srcObject = null;
          peerAudioRef.current.delete(peerId);
        }
      }
    }

    if (activePeers.length === 0) {
      setRemoteLevel(0);
      setAudioUnlockNeeded(false);
    }
  }, [clientId, createPeerConnection, participants, roomId, setTransientBusyMessage]);

  useEffect(() => {
    let cancelled = false;

    const setup = async () => {
      if (startedRef.current) {
        return;
      }
      startedRef.current = true;
      if (!roomId || !isValidPin) {
        setJoinState("error");
        setError("PIN invalide.");
        return;
      }

      try {
        const storedId = window.localStorage.getItem("talky_client_id");
        const newId = storedId && storedId.length > 6 ? storedId : crypto.randomUUID();
        window.localStorage.setItem("talky_client_id", newId);

        const join = await joinRoom(roomId, newId);
        if (cancelled) {
          return;
        }

        if (!join.ok) {
          if (join.reason === "full") {
            setJoinState("full");
            setError(null);
          } else {
            setJoinState("error");
            setError("Impossible de rejoindre la room.");
          }
          return;
        }

        setClientId(newId);

        const micStream = await requestMicrophoneStream();
        if (cancelled) {
          micStream.getTracks().forEach((track) => track.stop());
          return;
        }

        const [micTrack] = micStream.getAudioTracks();
        if (!micTrack) {
          throw new Error("Aucune piste micro.");
        }

        micTrack.enabled = false;
        localStreamRef.current = micStream;
        localTrackRef.current = micTrack;
        setMicReady(true);

        setJoinState("ready");
        setError(null);

        const unsub = subscribeParticipants(roomId, (list) => {
          if (!cancelled) {
            setParticipants(list);
          }
        });
        roomUnsubRef.current = unsub;

        await heartbeatParticipant(roomId, newId);
        if (cancelled) {
          return;
        }

        heartbeatIntervalRef.current = window.setInterval(() => {
          void heartbeatParticipant(roomId, newId).catch(() => {
            // Retry on next heartbeat.
          });
        }, ROOM_HEARTBEAT_MS);
      } catch {
        setJoinState("error");
        setError("Permission micro ou configuration Firebase invalide.");
      }
    };

    const beforeUnload = () => {
      const activeClientId = clientIdRef.current;
      if (!activeClientId) {
        return;
      }

      void leaveRoom(roomId, activeClientId).catch(() => {
        // Best effort.
      });
    };

    window.addEventListener("beforeunload", beforeUnload);
    void setup();

    return () => {
      cancelled = true;
      startedRef.current = false;
      window.removeEventListener("beforeunload", beforeUnload);

      void stopTalking();
      closePeerConnections();

      if (roomUnsubRef.current) {
        roomUnsubRef.current();
        roomUnsubRef.current = null;
      }

      if (heartbeatIntervalRef.current !== null) {
        window.clearInterval(heartbeatIntervalRef.current);
        heartbeatIntervalRef.current = null;
      }

      if (busyTimeoutRef.current !== null) {
        window.clearTimeout(busyTimeoutRef.current);
        busyTimeoutRef.current = null;
      }
      if (remoteSignalIntervalRef.current !== null) {
        window.clearInterval(remoteSignalIntervalRef.current);
        remoteSignalIntervalRef.current = null;
      }

      if (localStreamRef.current) {
        for (const track of localStreamRef.current.getTracks()) {
          track.stop();
        }
        localStreamRef.current = null;
      }
      localTrackRef.current = null;
      if (audioContextRef.current) {
        void audioContextRef.current.close();
        audioContextRef.current = null;
      }
      pttDownAudioRef.current = null;
      pttUpAudioRef.current = null;
      backgroundLoopRef.current = null;
      remotePollInFlightRef.current = false;

      const activeClientId = clientIdRef.current;
      if (activeClientId) {
        void leaveRoom(roomId, activeClientId).catch(() => {
          // Best effort.
        });
      }
    };
  }, [closePeerConnections, isValidPin, roomId, stopTalking]);

  const statusLabel = useMemo(() => {
    if (joinState === "joining") {
      return "Connexion";
    }

    if (joinState === "full") {
      return "Occupe";
    }

    if (joinState === "error") {
      return "Erreur";
    }

    if (participants.length <= 1) {
      return "En attente";
    }

    if (connectionState === "connected") {
      return "Connecte";
    }

    if (connectionState === "connecting" || connectionState === "new") {
      return "Connexion";
    }

    return "Connexion";
  }, [connectionState, joinState, participants.length]);

  const statusClass = useMemo(() => statusLabel.toLowerCase().replaceAll(" ", "-"), [statusLabel]);

  return (
    <main className="shell">
      <div className="device">

        {/* Antenne */}
        <div className="device-antenna" aria-hidden="true">
          <div className="antenna-shaft" />
        </div>

        {/* Bande supérieure : marque + LEDs + TX/RX */}
        <div className="device-topstrip">
          <span className="brand-text">TALKY</span>
          <div className="led-row" aria-hidden="true">
            <span className={`led-dot ${joinState === "ready" ? "on" : ""}`} />
            <span className={`led-dot ${participants.length >= 2 ? "on" : ""}`} />
            <span className={`led-dot tx ${isTransmitting ? "on" : ""}`} />
          </div>
          <span className={`state-label ${isTransmitting ? "live" : ""}`}>
            {isTransmitting ? "TX" : "RX"}
          </span>
        </div>

        {/* Grille de haut-parleur */}
        <div className="speaker-holes" aria-hidden="true" />

        {/* Écran LCD — canal comme fréquence */}
        <div className="lcd-screen">
          <span className="lcd-label">CH</span>
          {joinState === "full" ? (
            <>
              <div className="lcd-freq lcd-warn">SATURE</div>
              <div className="lcd-sub">MAX {MAX_PARTICIPANTS} UNITES</div>
            </>
          ) : joinState === "error" ? (
            <>
              <div className="lcd-freq lcd-error">ERREUR</div>
              <div className="lcd-sub">VERIFIER CONFIG</div>
            </>
          ) : (
            <>
              <div className="lcd-freq">
                <span className="lcd-prefix">462.</span>
                <span className="lcd-pin">{roomId || "----"}</span>
              </div>
              <div className={\`lcd-sub \${statusClass}\`}>
                <span className="lcd-status">{statusLabel.toUpperCase()}</span>
                <span className="lcd-count">
                  {participants.length}/{MAX_PARTICIPANTS}
                </span>
              </div>
            </>
          )}
        </div>

        {/* Panneau de contrôle */}
        {joinState === "full" ? (
          <div className="device-panel">
            <Link className="btn-back" href="/">
              &larr; RETOUR
            </Link>
          </div>
        ) : (
          <div className="device-panel">

            {/* Indicateur RX */}
            <div className="rx-band">
              <span className={`led-dot ${remoteSpeaking ? "on" : ""}`} />
              <span className="rx-label">
                {remoteSpeaking ? "SIGNAL RX DETECTE" : "RX EN VEILLE"}
              </span>
            </div>

            {/* Bouton PTT */}
            <div className="ptt-zone">
              <button
                type="button"
                className={`ptt-button ${isTransmitting ? "live" : ""}`}
                disabled={!canTransmit}
                onPointerDown={(event) => {
                  event.preventDefault();
                  event.stopPropagation();
                  event.currentTarget.setPointerCapture(event.pointerId);
                  handlePressStart();
                }}
                onMouseDown={(event) => {
                  event.preventDefault();
                }}
                onPointerUp={(event) => {
                  event.preventDefault();
                  event.stopPropagation();
                  if (event.currentTarget.hasPointerCapture(event.pointerId)) {
                    event.currentTarget.releasePointerCapture(event.pointerId);
                  }
                  handlePressEnd();
                }}
                onPointerLeave={handlePressEnd}
                onPointerCancel={handlePressEnd}
                onContextMenu={(event) => event.preventDefault()}
              >
                {isTransmitting ? "TX..." : "PTT"}
              </button>
            </div>

            {/* VUmètres */}
            <div className="meter-stack">
              <div
                className={`audio-meter ${isTransmitting ? "live" : ""}`}
                style={{ "--level": level.toFixed(2) } as React.CSSProperties}
              >
                <span className="audio-meter-fill" />
                <span className="audio-meter-scan" />
                <div className="audio-meter-bars" aria-hidden="true">
                  {Array.from({ length: 12 }).map((_, index) => (
                    <span key={index} className="audio-bar" />
                  ))}
                </div>
              </div>
              <div
                className={`audio-meter rx-meter ${remoteSpeaking ? "live" : ""}`}
                style={{ "--level": remoteLevel.toFixed(2) } as React.CSSProperties}
              >
                <span className="audio-meter-fill" />
                <span className="audio-meter-scan" />
              </div>
            </div>

            {/* Actions */}
            <div className={`device-actions ${isHolding ? "locked" : ""}`}>
              <button type="button" className="btn-action" onClick={copyLink}>
                {copied ? "COPIE" : "LIEN"}
              </button>
              <Link className="btn-action" href="/">
                QUITTER
              </Link>
            </div>

            {/* Audio unlock */}
            {participants.length > 1 && audioUnlockNeeded && (
              <button
                type="button"
                className="btn-unlock"
                onClick={() => {
                  void resumeRemoteAudioPlayback();
                }}
              >
                &#9654; ACTIVER AUDIO
              </button>
            )}

            {busyMessage && <p className="device-msg warn">{busyMessage}</p>}
            {error && <p className="device-msg error">{error}</p>}

          </div>
        )}

        {/* Trous de microphone */}
        <div className="mic-holes" aria-hidden="true" />

      </div>
    </main>
  );
}

